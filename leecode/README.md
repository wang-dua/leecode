# 704 二分查找: 
遵循循环不变量原则, 双闭区间, 半开半闭区分清楚

# 59 螺旋矩阵: 
**同样遵循循环一致性原则**, 利用 count 变量 填充, 设定偏移值offset用于循环条件, 按圈数循环,  同时n为奇数时注意最后要填充中间值,

# 203 移除链表元素: 
1. **创建dummyHead 和 无dummyHead 是两种思路**, 前者更明了-返回dummHead_->next_, 后者需要单独设置循环清除head
2. 需要注意对于循环条件的->next使用, 不能对nullptr使用->next

# 707 设计链表
1. get(index)	找到第 index 个节点（从 0 开始）
2. addAtIndex(i)	找到 第 i 个节点的前一个节点（插在前面）
3. deleteAtIndex(i)	找到 第 i 个节点的前一个节点（删除第 i 个）

4. 统一遍历: 从dummyHead开始i=0, 到i < index结束, 这样get() 时再走一步：curr = curr->next;

5. add() 时：curr 就是第 index 个节点的前一个，正好插入

6. delete() 时：curr 也是第 index 个节点的前一个，正好删除

# 206 反转链表
三种方法最便捷容易的就是双指针, 放入vector会发生内容不够错误, 递归应该新建一个方法
1. 使用双指针

2. 利用双指针递归

3. 放vector



#  142 环形链表

1. 链表的环存在于尾巴
2. 是否存在环: **快慢指针**, 如果存在两指针必在环内相遇
3. 求环的入口: 如果快慢指针相遇, 则从**head到入口** 与 从**相遇处到入口的距离**相同
4. 求环的长度: 在 3 的基础上

# 242 字母异位词: 相同字母不同顺序的单词
1. 暴力解法中, 找到相同字母后需要将该字母用其他字符覆盖掉, 避免重复匹配, 并且需要一个外层循环bool值, 找到字母修改为true, 一旦没找到就return false
2. 最便捷的方法, 使用一个26长度的数组(或是哈希表), 将字母的相对码映射为索引, 一个循环增加, 一个循环减少

# 349 求数组交集

1. 有数值大小限制, 可以自己用数组映射hash表, 注意表长为最大数值+1, 如果数值跨度过大并分散, 会造成空间浪费, 但很快
2. 无数值大小限制, 可以使用 unordered_set(set, multiset)容器的find方法,  unordered_set也是使用hash实现的, 时间较长

# 1 两数之和

1. 使用unordered_map是最好最快的方法, unordered_map无序 使用hash实现

2. 最重要的是需要考虑代码逻辑, **在遍历数组元素时, 应该直接判断另一个key的索引在不在map中, 最后再插入该遍历元素 pair{nums[i], i} 到map中**, 这样能避免使用同一个元素两次

3. 总之记住该方法, 本以为multimap 可以重复key会简单一点, 但是还是会遇到使用重复元素的情况, 除非使用`equal_range(key)`：返回一个 pair，表示 multimap 中所有 key == 指定值 的元素区间 `[first, second)`；, 但是这样时间复杂度又高了

4. 需要注意的是一些map: 

   - | 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
     | ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
     | std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(log n) | O(log n) |
     | std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
     | std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

# 27 移除数组元素(并不容易)
1. 使用双循环, 需要尤其注意的是随着数组元素的移除**, 当前i--, 并且size--, 否**则会索引错误
1. **使用双指针法.** 时间复杂度O(n), 当fast指针发现val时, 会让slow指针原地等待**, 该方法比较奇怪, 记住**

# 151 翻转字符串中的单词(难)

1. **sstream头文件中可以对string对象进行IO,** 比如string对象作为输入流,自动去除空格, 该方法需要额外的空间, 时间复杂度O(n) , 容易理解
2. **原地算法**(*******): 需要
   1. ?	deleteExtraSpaces: 将str的前后空格删除,  并手动添加单词之间的空格, 该方法使用了27中的快慢指针, 宏观上的循环 slow是按单词移动的, 要手动添加单词之间的空格 str[slow++] = ' ';, 且在覆盖元素的时候, fast和slow都是使用while循环覆盖整个单词
   2. reverseStr(str&, start, end): swap将字符串翻转
   3. reverseWord: deleteExtraSpaces -> reverseStr整个字符串 -> 再对每个空格隔开的单词reverseStr