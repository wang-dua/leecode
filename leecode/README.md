# 704 二分查找: 
遵循循环不变量原则, 双闭区间, 半开半闭区分清楚

# 59 螺旋矩阵: 
**同样遵循循环一致性原则**, 利用 count 变量 填充, 设定偏移值offset用于循环条件, 按圈数循环,  同时n为奇数时注意最后要填充中间值,

# 203 移除链表元素: 
1. **创建dummyHead 和 无dummyHead 是两种思路**, 前者更明了-返回dummHead_->next_, 后者需要单独设置循环清除head
2. 需要注意对于循环条件的->next使用, 不能对nullptr使用->next

# 707 设计链表
1. get(index)	找到第 index 个节点（从 0 开始）
2. addAtIndex(i)	找到 第 i 个节点的前一个节点（插在前面）
3. deleteAtIndex(i)	找到 第 i 个节点的前一个节点（删除第 i 个）

4. 统一遍历: 从dummyHead开始i=0, 到i < index结束, 这样get() 时再走一步：curr = curr->next;

5. add() 时：curr 就是第 index 个节点的前一个，正好插入

6. delete() 时：curr 也是第 index 个节点的前一个，正好删除

# 206 反转链表
三种方法最便捷容易的就是双指针, 放入vector会发生内容不够错误, 递归应该新建一个方法
1. 使用双指针

2. 利用双指针递归

3. 放vector



#  142 环形链表

1. 链表的环存在于尾巴
2. 是否存在环: **快慢指针**, 如果存在两指针必在环内相遇
3. 求环的入口: 如果快慢指针相遇, 则从**head到入口** 与 从**相遇处到入口的距离**相同
4. 求环的长度: 在 3 的基础上

# 242 字母异位词: 相同字母不同顺序的单词
1. 暴力解法中, 找到相同字母后需要将该字母用其他字符覆盖掉, 避免重复匹配, 并且需要一个外层循环bool值, 找到字母修改为true, 一旦没找到就return false
2. 最便捷的方法, 使用一个26长度的数组(或是哈希表), 将字母的相对码映射为索引, 一个循环增加, 一个循环减少

# 349 求数组交集

1. 有数值大小限制, 可以自己用数组映射hash表, 注意表长为最大数值+1, 如果数值跨度过大并分散, 会造成空间浪费, 但很快
2. 无数值大小限制, 可以使用 unordered_set(set, multiset)容器的find方法,  unordered_set也是使用hash实现的, 时间较长

# 1 两数之和

1. 使用unordered_map是最好最快的方法, unordered_map无序 使用hash实现

2. 最重要的是需要考虑代码逻辑, **在遍历数组元素时, 应该直接判断另一个key的索引在不在map中, 最后再插入该遍历元素 pair{nums[i], i} 到map中**, 这样能避免使用同一个元素两次

3. 总之记住该方法, 本以为multimap 可以重复key会简单一点, 但是还是会遇到使用重复元素的情况, 除非使用`equal_range(key)`：返回一个 pair，表示 multimap 中所有 key == 指定值 的元素区间 `[first, second)`；, 但是这样时间复杂度又高了

4. 需要注意的是一些map: 

   - | 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
     | ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
     | std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(log n) | O(log n) |
     | std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
     | std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

# 27 移除数组元素(并不容易)
1. 使用双循环, 需要尤其注意的是随着数组元素的移除**, 当前i--, 并且size--, 否**则会索引错误
1. **使用双指针法.** 时间复杂度O(n), 当fast指针发现val时, 会让slow指针原地等待**, 该方法比较奇怪, 记住**

# 151 翻转字符串中的单词(难)

1. **sstream头文件中可以对string对象进行IO,** 比如string对象作为输入流,自动去除空格, 该方法需要额外的空间, 时间复杂度O(n) , 容易理解
2. **原地算法**(*******): 需要
   1. ?	deleteExtraSpaces: 将str的前后空格删除,  并手动添加单词之间的空格, 该方法使用了27中的快慢指针, 宏观上的循环 slow是按单词移动的, 要手动添加单词之间的空格 str[slow++] = ' ';, 且在覆盖元素的时候, fast和slow都是使用while循环覆盖整个单词
   2. reverseStr(str&, start, end): swap将字符串翻转
   3. reverseWord: deleteExtraSpaces -> reverseStr整个字符串 -> 再对每个空格隔开的单词reverseStr

# 459 重复的子字符串(先跳过)

# 20 有效地括号匹配

1. 使用栈解决问题, 遍历括号字符串, 当遇到左括号, 入栈相应的右括号, 遇到右括号, 检查栈顶元素是否匹配
2. 关键问题在于, **如何写判断语句**
3. 括号不匹配分为两大类: **遍历到当前位置时左右括号数量不匹配**, **遍历到当前位置时左右括号数量匹配但是类型不匹配**
4. 前者又分为 **左括号多:** 遍历完了之后, 栈中还有元素(对应的右括号), **右括号多:** 遍历过程中发现栈为空
5. 所以遍历的判断逻辑是 如果遇到左括号入栈右括号,  遇到右括号则出栈---如果栈空则是右括号多, 如果括号不匹配false, 如果匹配则弹出元素, 遍历结束检查栈是否为空, 如果是空的则左括号多

# 150 逆波兰表达式求值
1. 逆波兰表达式即为后缀表达式, 计算机友好
2. 后缀表达式转中缀表达式(人类友好): 遍历中, 遇到数字入栈, 遇到符号出栈两个数字计算, 结果入栈, 最后栈顶元素即为计算结果

# 239 滑动窗口最大值
**使用双端队列, 维护一个单调队列, 该队列队尾入队, 队头和队尾都能出队, 队头pop过期元素, 队尾pop在push操作中, pop出比入队元素小的值, 队头到队尾依次降值**
1. 该单调队列 pop() 是pop_front(), 是由滑动窗口造成的过期元素弹出, 每次pop出的一定是当前最大值
2. push()操作, 先从队尾 pop_back()弹出比当前入队的value小的元素, 再入队新元素
3. 求解时, 先添加进K(滑动窗口大小)个元素求值, 从数组第1个元素开始pop(), 从滑动窗口后面的第一个元素开始push(), 直到push()到最后一个元素

# 144 145 94 二叉树的递归遍历
有两种方法
1. 使用辅助函数 void f(root, &result), 额外写函数, 参数包含root 和 数组
2. 或者直接返回 结果, 再根据遍历方式插入 (更麻烦)

# 递归法三要素
1. 确定递归函数的参数和返回值
2. 确定终止条件
3. 编写单层的递归处理逻辑

# 二叉树栈迭代遍历
迭代遍历是利用栈先进后出
1. **前序遍历和后序遍历**, 原理相同, 前序遍历中先将root入栈, 使用循环直到栈空, 在循环中先出栈 再入右孩子 左孩子, 后序遍历, 将前序的左右孩子更改入栈顺序, 再反转结果即可
2. 中序遍历, 使用迭代不是很直观, 建议记住

# 二叉树层次遍历
1. 利用队列先进先出
2. 最重要的一点是, 在开始进入每一层循环时, 当前队列长度就是当前层的节点数, 可以通过q.size()将每一层分割处理 

# 226 翻转二叉树
前序遍历 or 层次遍历都可以解决问题, 注意层次遍历应当先入队再处理业务

# 101 判断对称二叉树
1. 栈, 队列, 递归方法都可以解决问题, 注意这里比较的不是左右孩子, 而是外侧左右节点, 内侧左右节点
2. 使用容器: 取出两个元素, 不对称 return false, 都为空进行下一轮循环continue, 当非空对称时, 外侧节点进容器, 内侧节点进容器    
3. 使用递归:

    1. 参数和返回值: bool compare(TreeNode* leftside, TreeNode* rightside)
    2. 返回条件: 不对称 return false, 都为空时 return true
    3. 单层递归逻辑: 当都不为空且对称时, 可以进入递归, 先递归外层, 再递归内层, 返回内外层与运算

# 104 求二叉树的深度
1. 后序递归法, 返回左右子树高度最大值 +１
1. 层序遍历：　最好理解

# 110 判断平衡二叉树
1. 用后序递归求二叉树的深度, 并判断左右差值, 差值>1 直接返回深度 -1
2. 在求左右子树的深度时, 伴随着判断深度是否是-1, 是 -1 直接返回 -1终止

# 257 求二叉树所有路径
这里采用前序遍历, 但是用到了回溯, 也就是说如果想要获取所有的路径, 当前路径保存后应当回溯到父节点
1. path采用值传递到下一层递归, 递归的path修改不会影响上一层path, 直到叶子结点, 一条path便可以生成, 但是值传递会反复拷贝path, 速度慢
2. path引用传递, 每一层递归使用同一个path, 当遇到叶子节点, 保存路径, 再pop掉当前节点, 否则如果不是叶子节点便可以进入左右子树的递归, 当一棵树左右递归完成, 也应当pop掉当前节点, 这样才能保证每一条路径后续的生成

# 700 二叉搜索树搜索
1. 利用递归法, 中, 小了往左, 大了往右
2. 或者直接迭代法, 利用循环, 较为简单

# 98 验证二叉搜索树
1. 二叉搜索树的中序序列是严格递增序列
2. 递归: 前->判断当前节点是否在min和max范围内; 左->左子树的所有值在 min和node->val之间; 右->右子树的值在node->val和max之间

# 701 二叉搜索树的插入
1. 当插入操作在在叶子时, 可以不改变树的结构即可插入
2. 当遇到空节点即可终止 生成新节点返回, 对于左右子树的递归, root->left和root->right接收返回值, 最后返回root即可

# 257 二叉搜索树的删除
1. 删除会涉及到树的重构, 还是使用递归
2. 先确定参数和返回值->终止条件是空的时候返回->处理单层递归:共有五种情况

    1. 遇到空节点, 没找到, 返回nullptr, 也就是终止条件
    2. 找到了, 该节点是叶子, 直接删除, 返回root
    3. 找到了, 只有左孩子, 删除节点, 返回其左孩子, (因为递归的时候使用root->left和root->right接收返回值)
    4. 找到了, 只有右孩子, 删除节点, 返回其右孩子
    5. **左右孩子都有**, 处理: 该节点的右孩子的最左节点->left = 该节点的left, 删除该节点, 返回该节点的右孩子
3. 进入左右递归

# 回溯法三部曲

1. 回溯函数模板返回值以及参数: 函数返回值一般为void, 参数需要根据不同题目确定

2. 回溯函数终止条件 

    ```text
    if (终止条件) {
        存放结果;
        return;
    }
    ```

    

3. 回溯搜索的遍历过程: for循环的条件遍历宽度, 循环体里的递归确定深度

    ```text
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
    ```

4. 回溯模板

   ```text
   void backtracking(参数) {
       if (终止条件) {
           存放结果;
           return;
       }
   
       for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
           处理节点;
           backtracking(路径，选择列表); // 递归
           回溯，撤销处理结果
       }
   }
   ```

# 选出组合数 77, 216, 39, 40
77, 216, 39, 40都涉及到从一个序列中选出数字, 进行组合使其满足某种条件, 返回该结果
1. 从一个序列中组合数字都需要用到 startidx, 如果允许重复数字, 那么在进入递归的时候不需要 传入 (startidx)i+1
2. 无论是从一个 有序序列还是 一个vector选数字, 都遵循下面的方法(组合回溯模板):

    1. 遇到条件返回
    2. for循环处理
3. 40 中需要注意的是给定的数组candidates, 中会有重复元素, 需要用到vector<bool> used数组判断, 在树中, 同一层不能使用同一个元素 

# 子集 78 90
和组合 本质上是一样的, 需要先确定终止条件, 再写for, 如果组合问题都抽象为一棵树, **那么求组合是找出叶子节点, 求子集可以看做是找所有节点**
1. 78 是普通集合求子集, 每次递归都添加节点, 直到startidx == size, 所以终止条件是startidx == size, 且添加节点写在终止条件前
2. 90 是数组中有重复元素, 求子集, 跟40类似, 在同层的for循环取值时, 不再使用重复的, 在进入递归前 used[i] = true, 递归出来后回溯时 used[i] = false, false说明是同层

# 全排列 46 47
1. 46是无重复元素全排列, 由于排列需要用到所有元素, 所以没有startidx, 每次for循环都是从0开始, 只是使用了used记录每个位置上的元素是否使用, 这里是为了 在同一个树枝上取消使用重复元素
2. 47是有重复元素的数组 进行全排列, 这里在46的基础上还要判断 同一层的元素不能再使用相同的, 跟90的处理方法相同

# 455 贪心算法: 分发饼干
1. 优先满足小食量的孩子, 即排序后, 从前面开始向后判断, 需要注意的是这种情况下, for循环的索引应当是 饼干, 只有当满足孩子后, 孩子的索引才会变化
2. 优先满足大食量的孩子, 排序后, 从后面开始向前判断, for循环的索引是孩子, 当满足孩子后, 饼干索引变化

# 376 摆动序列
1. 需要记录摆动的最长序列, 当size() < 2, 直接返回size()
2. 从i = 1开始, up = down = 1, 只需要判断上坡和下坡即可, 上坡时up依赖down, 下坡是down依赖up. 而不需要判断前>0, 后 < 0, 即使是一直单调的坡, up和down也不会一直增加, 两者互相依赖, 
最后取 up down 最大值即可

# 42 分发糖果
局部情况下: 用右比左, 依次增加糖果, 再从末尾开始, 用左比右, 增加糖果

# 860 柠檬水找零
三种情况, 五元, 十元, 二十元, 只需要着重判断20元时: 优先用10元找零, 因为10元只能找20元零钱, 而5元都可以找

# 动态规划:
使用dp数组边利用旧数据计算, 边填充新数据, 可以分为五步
1. 确定dp数组是什么, 下标i和dp[i]分别表示什么
2. 确定新旧数据的推导规则: 例如dp[i] = dp[i-1]....
3. 如何初始化dp数组, 一般要确定前几个元素
4. 确定遍历顺序, 具体分析
5. 不确定的情况可以打印输出查看错误

# 动态规划- 44斐波那契数 45爬楼梯 46最小花费爬楼梯 62不同路径
1. 都是利用dp[i] = dp[i-2] + dp[i-1]类似的推导, 确定好dp初始化及dp[i]和下标的意义即可
2. 62使用了二维数组, 和一维同理

# 背包问题:　掌握01背包和完全背包
## 01背包问题, m个物品, 背包容量为n
物品每样只有一个, 放入或不放入
1. 建立动态规划问题, dp[i][j]: 在背包重量为j时, 选出 从物品0到物品i 多个物品, 放入背包, 可以存放的最大价值
2.推导: dp 每一行是 物品i(0~(m-1)), 每一列是背包重量, 从0到j(j+1列), 一个物品要么选, 要么不选, 背包容量为j时, 物品编号为i时, 且当前weight[i] <= j
	 * 不选i, 价值为 dp[i-1][j]
	 * 选i, 价值为 value[i] + dp[i-1][j-weight[i], dp[i-1][j-weight[i]]是去除了i能装的最大价值
	 * 取两者最大值

3. 初始化: 第一行将物品0先填入, 放不下为填0, 第一列全为0
4. 遍历: 最直观的从dp[1][1]按行遍历

## 01背包问题, m个物品, 背包容量为n, 一维(滚动)数组实现
1. `dp[i][j] = max{dp[i-1][j], value[i] + dp[i-1][j-weight[i]`, 推导公式所在行i只与上一行i-1有关, 所以可以像44 45动态规划问题(把一维数组缩短为两个元素数组), 我们把二维数组降为一维数组, 每一次最外层循环覆盖旧数组
2. 原先`d[i][j]`, 现在变为`d[j]`, 依然两层循环, 但是内层循环的j要变为倒序, 这与推导公式有关, 因为`d[j-weight[i]]`是向前的, 我们在每一次更新数组的时候, 做的是与上一层i的比较, 如果顺序遍历j, 可能在更新某个元素的时候使用到了新数据, 这是错误的, 但是倒序遍历j就不会发生, `j-weight[i]`始终会向前


# 416 分割等和子集(01背包应用)
1. 把问题转化为背包问题: 背包最大容量为 sum/2, 物品有nums.size() 个, 每个数字值 是 weight, 同样也是value
2. 当背包容量为sum/2, 可以放入数字的和最大为 sum/2 时, 便可以分割等和子集, 另一个子集要么空, 要么和为sum/2

# 完全背包问题 
1. 每一样物品不限数量可以放多个
2. dp[i][j]: 在背包重量为j时, 选出 从物品0到物品i, 每个物品可以放入多个, 放入背包, 可以存放的最大价值
3. 当容量为j时, 对于i物品, 且 `j >= weight[i]`,如果不选择i, 那么价值是 `dp[i-1][j]`, **如果选择了i, 剩余容量是`j-weight[i]`, 这时候是与01背包的区别**: **物品可以选择多个, 所以这个时候的价值应该是`dp[i][j-weight[i]] + value[i]`, 表示在重量限制下选取物品 0-i的最大价值, 而不是dp[i-1][j-weight[i]]**

# 完全背包问题依然可以转化为一维数组