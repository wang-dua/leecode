# 704 二分查找: 
遵循循环不变量原则, 双闭区间, 半开半闭区分清楚

# 59 螺旋矩阵: 
**同样遵循循环一致性原则**, 利用 count 变量 填充, 设定偏移值offset用于循环条件, 按圈数循环,  同时n为奇数时注意最后要填充中间值,

# 203 移除链表元素: 
1. **创建dummyHead 和 无dummyHead 是两种思路**, 前者更明了-返回dummHead_->next_, 后者需要单独设置循环清除head
2. 需要注意对于循环条件的->next使用, 不能对nullptr使用->next

# 707 设计链表
1. get(index)	找到第 index 个节点（从 0 开始）
2. addAtIndex(i)	找到 第 i 个节点的前一个节点（插在前面）
3. deleteAtIndex(i)	找到 第 i 个节点的前一个节点（删除第 i 个）

4. 统一遍历: 从dummyHead开始i=0, 到i < index结束, 这样get() 时再走一步：curr = curr->next;

5. add() 时：curr 就是第 index 个节点的前一个，正好插入

6. delete() 时：curr 也是第 index 个节点的前一个，正好删除

# 206 反转链表
三种方法最便捷容易的就是双指针, 放入vector会发生内容不够错误, 递归应该新建一个方法
1. 使用双指针

2. 利用双指针递归

3. 放vector



#  142 环形链表

1. 链表的环存在于尾巴
2. 是否存在环: **快慢指针**, 如果存在两指针必在环内相遇
3. 求环的入口: 如果快慢指针相遇, 则从**head到入口** 与 从**相遇处到入口的距离**相同
4. 求环的长度: 在 3 的基础上

# 242 字母异位词: 相同字母不同顺序的单词
1. 暴力解法中, 找到相同字母后需要将该字母用其他字符覆盖掉, 避免重复匹配, 并且需要一个外层循环bool值, 找到字母修改为true, 一旦没找到就return false
2. 最便捷的方法, 使用一个26长度的数组(或是哈希表), 将字母的相对码映射为索引, 一个循环增加, 一个循环减少

# 349 求数组交集

1. 有数值大小限制, 可以自己用数组映射hash表, 注意表长为最大数值+1, 如果数值跨度过大并分散, 会造成空间浪费, 但很快
2. 无数值大小限制, 可以使用 unordered_set(set, multiset)容器的find方法,  unordered_set也是使用hash实现的, 时间较长

# 1 两数之和

1. 使用unordered_map是最好最快的方法, unordered_map无序 使用hash实现

2. 最重要的是需要考虑代码逻辑, **在遍历数组元素时, 应该直接判断另一个key的索引在不在map中, 最后再插入该遍历元素 pair{nums[i], i} 到map中**, 这样能避免使用同一个元素两次

3. 总之记住该方法, 本以为multimap 可以重复key会简单一点, 但是还是会遇到使用重复元素的情况, 除非使用`equal_range(key)`：返回一个 pair，表示 multimap 中所有 key == 指定值 的元素区间 `[first, second)`；, 但是这样时间复杂度又高了

4. 需要注意的是一些map: 

   - | 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
     | ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
     | std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(log n) | O(log n) |
     | std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
     | std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

# 27 移除数组元素(并不容易)
1. 使用双循环, 需要尤其注意的是随着数组元素的移除**, 当前i--, 并且size--, 否**则会索引错误
1. **使用双指针法.** 时间复杂度O(n), 当fast指针发现val时, 会让slow指针原地等待**, 该方法比较奇怪, 记住**

# 151 翻转字符串中的单词(难)

1. **sstream头文件中可以对string对象进行IO,** 比如string对象作为输入流,自动去除空格, 该方法需要额外的空间, 时间复杂度O(n) , 容易理解
2. **原地算法**(*******): 需要
   1. ?	deleteExtraSpaces: 将str的前后空格删除,  并手动添加单词之间的空格, 该方法使用了27中的快慢指针, 宏观上的循环 slow是按单词移动的, 要手动添加单词之间的空格 str[slow++] = ' ';, 且在覆盖元素的时候, fast和slow都是使用while循环覆盖整个单词
   2. reverseStr(str&, start, end): swap将字符串翻转
   3. reverseWord: deleteExtraSpaces -> reverseStr整个字符串 -> 再对每个空格隔开的单词reverseStr

# 459 重复的子字符串(先跳过)

# 20 有效地括号匹配

1. 使用栈解决问题, 遍历括号字符串, 当遇到左括号, 入栈相应的右括号, 遇到右括号, 检查栈顶元素是否匹配
2. 关键问题在于, **如何写判断语句**
3. 括号不匹配分为两大类: **遍历到当前位置时左右括号数量不匹配**, **遍历到当前位置时左右括号数量匹配但是类型不匹配**
4. 前者又分为 **左括号多:** 遍历完了之后, 栈中还有元素(对应的右括号), **右括号多:** 遍历过程中发现栈为空
5. 所以遍历的判断逻辑是 如果遇到左括号入栈右括号,  遇到右括号则出栈---如果栈空则是右括号多, 如果括号不匹配false, 如果匹配则弹出元素, 遍历结束检查栈是否为空, 如果是空的则左括号多

# 150 逆波兰表达式求值
1. 逆波兰表达式即为后缀表达式, 计算机友好
2. 后缀表达式转中缀表达式(人类友好): 遍历中, 遇到数字入栈, 遇到符号出栈两个数字计算, 结果入栈, 最后栈顶元素即为计算结果

# 239 滑动窗口最大值
**使用双端队列, 维护一个单调队列, 该队列队尾入队, 队头和队尾都能出队, 队头pop过期元素, 队尾pop在push操作中, pop出比入队元素小的值, 队头到队尾依次降值**
1. 该单调队列 pop() 是pop_front(), 是由滑动窗口造成的过期元素弹出, 每次pop出的一定是当前最大值
2. push()操作, 先从队尾 pop_back()弹出比当前入队的value小的元素, 再入队新元素
3. 求解时, 先添加进K(滑动窗口大小)个元素求值, 从数组第1个元素开始pop(), 从滑动窗口后面的第一个元素开始push(), 直到push()到最后一个元素

# 144 145 94 二叉树的递归遍历
有两种方法
1. 使用辅助函数 void f(root, &result), 额外写函数, 参数包含root 和 数组
2. 或者直接返回 结果, 再根据遍历方式插入 (更麻烦)

# 二叉树利用栈迭代遍历
迭代遍历是利用栈先进后出
1. **前序遍历和后序遍历**, 原理相同, 前序遍历中先将root入栈, 使用循环直到栈空, 在循环中先出栈 再入右孩子 左孩子, 后序遍历, 将前序的左右孩子更改入栈顺序, 再反转结果即可
2. 中序遍历, 使用迭代不是很直观, 建议记住

# 二叉树层次遍历
